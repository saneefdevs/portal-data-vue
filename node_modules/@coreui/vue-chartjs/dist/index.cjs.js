'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var Chart = require('chart.js/auto');
var chartjs = require('chart.js');
var chartjs$1 = require('@coreui/chartjs');
var assign = require('lodash/assign');
var find = require('lodash/find');
var merge = require('lodash/merge');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var Chart__default = /*#__PURE__*/_interopDefaultLegacy(Chart);
var chartjs__namespace = /*#__PURE__*/_interopNamespace(chartjs);
var assign__default = /*#__PURE__*/_interopDefaultLegacy(assign);
var find__default = /*#__PURE__*/_interopDefaultLegacy(find);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);

const CChart = vue.defineComponent({
    name: 'CChart',
    props: {
        /**
         * Enables custom html based tooltips instead of standard tooltips.
         *
         * @default true
         */
        customTooltips: {
            type: Boolean,
            default: true,
            required: false,
        },
        /**
         * The data object that is passed into the Chart.js chart (more info).
         */
        data: {
            type: [Object, Function],
            required: true,
        },
        /**
         * Height attribute applied to the rendered canvas.
         *
         * @default 150
         */
        height: {
            type: Number,
            default: 150,
            required: false,
        },
        /**
         * ID attribute applied to the rendered canvas.
         */
        id: {
            type: String,
            default: undefined,
            required: false,
        },
        /**
         * The options object that is passed into the Chart.js chart.
         *
         * {@link https://www.chartjs.org/docs/latest/general/options.html More Info}
         */
        options: {
            type: Object,
            default: undefined,
            required: false,
        },
        /**
         * The plugins array that is passed into the Chart.js chart (more info)
         *
         * {@link https://www.chartjs.org/docs/latest/developers/plugins.html More Info}
         */
        plugins: {
            type: Array,
            default: undefined,
            required: false,
        },
        /**
         * If true, will tear down and redraw chart on all updates.
         */
        redraw: Boolean,
        /**
         * Chart.js chart type.
         *
         * @type {'line' | 'bar' | 'radar' | 'doughnut' | 'polarArea' | 'bubble' | 'pie' | 'scatter'}
         */
        type: {
            type: String,
            default: 'bar',
            required: false,
        },
        /**
         * Width attribute applied to the rendered canvas.
         *
         * @default 300
         */
        width: {
            type: Number,
            default: 300,
            required: false,
        },
        /**
         * Put the chart into the wrapper div element.
         *
         * @default true
         */
        wrapper: {
            type: Boolean,
            default: true,
            required: false,
        },
    },
    emits: [
        /**
         * Proxy for Chart.js getDatasetAtEvent. Calls with dataset and triggering event.
         */
        'getDatasetAtEvent',
        /**
         * Proxy for Chart.js getElementAtEvent. Calls with single element array and triggering event.
         */
        'getElementAtEvent',
        /**
         * Proxy for Chart.js getElementsAtEvent. Calls with element array and triggering event.
         */
        'getElementsAtEvent',
    ],
    setup(props, { emit, slots }) {
        const canvasRef = vue.ref();
        let chart;
        const computedData = typeof props.data === 'function'
            ? canvasRef.value
                ? props.data(canvasRef.value)
                : { datasets: [] }
            : merge__default["default"]({}, props.data);
        const renderChart = () => {
            if (!canvasRef.value)
                return;
            if (props.customTooltips) {
                chartjs__namespace.defaults.plugins.tooltip.enabled = false;
                chartjs__namespace.defaults.plugins.tooltip.mode = 'index';
                chartjs__namespace.defaults.plugins.tooltip.position = 'nearest';
                chartjs__namespace.defaults.plugins.tooltip.external = chartjs$1.customTooltips;
            }
            chart = new Chart__default["default"](canvasRef.value, {
                type: props.type,
                data: computedData,
                options: props.options,
                plugins: props.plugins,
            });
        };
        const handleOnClick = (e) => {
            if (!chart)
                return;
            emit('getDatasetAtEvent', chart.getElementsAtEventForMode(e, 'dataset', { intersect: true }, false), e);
            emit('getElementAtEvent', chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, false), e);
            emit('getElementsAtEvent', chart.getElementsAtEventForMode(e, 'index', { intersect: true }, false), e);
        };
        const updateChart = () => {
            if (!chart)
                return;
            if (props.options) {
                chart.options = { ...props.options };
            }
            if (!chart.config.data) {
                chart.config.data = computedData;
                chart.update();
                return;
            }
            const { datasets: newDataSets = [], ...newChartData } = computedData;
            const { datasets: currentDataSets = [] } = chart.config.data;
            // copy values
            assign__default["default"](chart.config.data, newChartData);
            chart.config.data.datasets = newDataSets.map((newDataSet) => {
                // given the new set, find it's current match
                const currentDataSet = find__default["default"](currentDataSets, (d) => d.label === newDataSet.label && d.type === newDataSet.type);
                // There is no original to update, so simply add new one
                if (!currentDataSet || !newDataSet.data)
                    return newDataSet;
                if (!currentDataSet.data) {
                    currentDataSet.data = [];
                }
                else {
                    currentDataSet.data.length = newDataSet.data.length;
                }
                // copy in values
                assign__default["default"](currentDataSet.data, newDataSet.data);
                // apply dataset changes, but keep copied data
                return {
                    ...currentDataSet,
                    ...newDataSet,
                    data: currentDataSet.data,
                };
            });
            chart && chart.update();
        };
        const destroyChart = () => {
            if (chart)
                chart.destroy();
        };
        vue.onMounted(() => {
            renderChart();
        });
        vue.onUnmounted(() => {
            destroyChart();
        });
        vue.onUpdated(() => {
            if (props.redraw) {
                destroyChart();
                setTimeout(() => {
                    renderChart();
                }, 0);
            }
            else {
                updateChart();
            }
        });
        const canvas = (ref) => vue.h('canvas', {
            id: props.id,
            height: props.height,
            width: props.width,
            onClick: (e) => handleOnClick(e),
            role: 'img',
            ref: ref,
        }, {
            fallbackContent: () => slots.fallback && slots.fallback(),
        });
        return () => props.wrapper ? vue.h('div', { class: 'chart-wrapper' }, canvas(canvasRef)) : canvas(canvasRef);
    },
});

const CChartProps = {
    customTooltips: {
        type: Boolean,
        default: true,
        required: false,
    },
    data: {
        type: [Object, Function],
        required: true,
    },
    height: {
        type: Number,
        default: 150,
        required: false,
    },
    id: {
        type: String,
        default: undefined,
        required: false,
    },
    options: {
        type: Object,
        default: undefined,
        required: false,
    },
    plugins: {
        type: Array,
        default: undefined,
        required: false,
    },
    redraw: Boolean,
    width: {
        type: Number,
        default: 300,
        required: false,
    },
    wrapper: {
        type: Boolean,
        default: true,
        required: false,
    },
};
const CChartBar = vue.defineComponent({
    name: 'CChartBar',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'bar', ...props });
    },
});
const CChartBubble = vue.defineComponent({
    name: 'CChartBubble',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'bubble', ...props });
    },
});
const CChartDoughnut = vue.defineComponent({
    name: 'CChartDoughnut',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'doughnut', ...props });
    },
});
const CChartLine = vue.defineComponent({
    name: 'CChartLine',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'line', ...props });
    },
});
const CChartPie = vue.defineComponent({
    name: 'CChartPie',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'pie', ...props });
    },
});
const CChartPolarArea = vue.defineComponent({
    name: 'CChartPolarArea',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'polarArea', ...props });
    },
});
const CChartRadar = vue.defineComponent({
    name: 'CChartRadar',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'radar', ...props });
    },
});
const CChartScatter = vue.defineComponent({
    name: 'CChartScatter',
    props: CChartProps,
    setup(props) {
        return () => vue.h(CChart, { type: 'scatter', ...props });
    },
});
const CChartPlugin = {
    install: (app) => {
        app.component('CChart', CChart);
        app.component('CChartBar', CChartBar);
        app.component('CChartBubble', CChartBubble);
        app.component('CChartDoughnut', CChartDoughnut);
        app.component('CChartLine', CChartLine);
        app.component('CChartPie', CChartPie);
        app.component('CChartPolarArea', CChartPolarArea);
        app.component('CChartRadar', CChartRadar);
        app.component('CChartScatter', CChartScatter);
    },
};

exports.CChart = CChart;
exports.CChartBar = CChartBar;
exports.CChartBubble = CChartBubble;
exports.CChartDoughnut = CChartDoughnut;
exports.CChartLine = CChartLine;
exports.CChartPie = CChartPie;
exports.CChartPolarArea = CChartPolarArea;
exports.CChartRadar = CChartRadar;
exports.CChartScatter = CChartScatter;
exports["default"] = CChartPlugin;
//# sourceMappingURL=index.cjs.js.map
