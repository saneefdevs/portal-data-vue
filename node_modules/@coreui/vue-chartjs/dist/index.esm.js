import { defineComponent, ref, onMounted, onUnmounted, onUpdated, h } from 'vue';
import Chart from 'chart.js/auto';
import * as chartjs from 'chart.js';
import { customTooltips } from '@coreui/chartjs';
import assign from 'lodash/assign';
import find from 'lodash/find';
import merge from 'lodash/merge';

const CChart = defineComponent({
    name: 'CChart',
    props: {
        /**
         * Enables custom html based tooltips instead of standard tooltips.
         *
         * @default true
         */
        customTooltips: {
            type: Boolean,
            default: true,
            required: false,
        },
        /**
         * The data object that is passed into the Chart.js chart (more info).
         */
        data: {
            type: [Object, Function],
            required: true,
        },
        /**
         * Height attribute applied to the rendered canvas.
         *
         * @default 150
         */
        height: {
            type: Number,
            default: 150,
            required: false,
        },
        /**
         * ID attribute applied to the rendered canvas.
         */
        id: {
            type: String,
            default: undefined,
            required: false,
        },
        /**
         * The options object that is passed into the Chart.js chart.
         *
         * {@link https://www.chartjs.org/docs/latest/general/options.html More Info}
         */
        options: {
            type: Object,
            default: undefined,
            required: false,
        },
        /**
         * The plugins array that is passed into the Chart.js chart (more info)
         *
         * {@link https://www.chartjs.org/docs/latest/developers/plugins.html More Info}
         */
        plugins: {
            type: Array,
            default: undefined,
            required: false,
        },
        /**
         * If true, will tear down and redraw chart on all updates.
         */
        redraw: Boolean,
        /**
         * Chart.js chart type.
         *
         * @type {'line' | 'bar' | 'radar' | 'doughnut' | 'polarArea' | 'bubble' | 'pie' | 'scatter'}
         */
        type: {
            type: String,
            default: 'bar',
            required: false,
        },
        /**
         * Width attribute applied to the rendered canvas.
         *
         * @default 300
         */
        width: {
            type: Number,
            default: 300,
            required: false,
        },
        /**
         * Put the chart into the wrapper div element.
         *
         * @default true
         */
        wrapper: {
            type: Boolean,
            default: true,
            required: false,
        },
    },
    emits: [
        /**
         * Proxy for Chart.js getDatasetAtEvent. Calls with dataset and triggering event.
         */
        'getDatasetAtEvent',
        /**
         * Proxy for Chart.js getElementAtEvent. Calls with single element array and triggering event.
         */
        'getElementAtEvent',
        /**
         * Proxy for Chart.js getElementsAtEvent. Calls with element array and triggering event.
         */
        'getElementsAtEvent',
    ],
    setup(props, { emit, slots }) {
        const canvasRef = ref();
        let chart;
        const computedData = typeof props.data === 'function'
            ? canvasRef.value
                ? props.data(canvasRef.value)
                : { datasets: [] }
            : merge({}, props.data);
        const renderChart = () => {
            if (!canvasRef.value)
                return;
            if (props.customTooltips) {
                chartjs.defaults.plugins.tooltip.enabled = false;
                chartjs.defaults.plugins.tooltip.mode = 'index';
                chartjs.defaults.plugins.tooltip.position = 'nearest';
                chartjs.defaults.plugins.tooltip.external = customTooltips;
            }
            chart = new Chart(canvasRef.value, {
                type: props.type,
                data: computedData,
                options: props.options,
                plugins: props.plugins,
            });
        };
        const handleOnClick = (e) => {
            if (!chart)
                return;
            emit('getDatasetAtEvent', chart.getElementsAtEventForMode(e, 'dataset', { intersect: true }, false), e);
            emit('getElementAtEvent', chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, false), e);
            emit('getElementsAtEvent', chart.getElementsAtEventForMode(e, 'index', { intersect: true }, false), e);
        };
        const updateChart = () => {
            if (!chart)
                return;
            if (props.options) {
                chart.options = { ...props.options };
            }
            if (!chart.config.data) {
                chart.config.data = computedData;
                chart.update();
                return;
            }
            const { datasets: newDataSets = [], ...newChartData } = computedData;
            const { datasets: currentDataSets = [] } = chart.config.data;
            // copy values
            assign(chart.config.data, newChartData);
            chart.config.data.datasets = newDataSets.map((newDataSet) => {
                // given the new set, find it's current match
                const currentDataSet = find(currentDataSets, (d) => d.label === newDataSet.label && d.type === newDataSet.type);
                // There is no original to update, so simply add new one
                if (!currentDataSet || !newDataSet.data)
                    return newDataSet;
                if (!currentDataSet.data) {
                    currentDataSet.data = [];
                }
                else {
                    currentDataSet.data.length = newDataSet.data.length;
                }
                // copy in values
                assign(currentDataSet.data, newDataSet.data);
                // apply dataset changes, but keep copied data
                return {
                    ...currentDataSet,
                    ...newDataSet,
                    data: currentDataSet.data,
                };
            });
            chart && chart.update();
        };
        const destroyChart = () => {
            if (chart)
                chart.destroy();
        };
        onMounted(() => {
            renderChart();
        });
        onUnmounted(() => {
            destroyChart();
        });
        onUpdated(() => {
            if (props.redraw) {
                destroyChart();
                setTimeout(() => {
                    renderChart();
                }, 0);
            }
            else {
                updateChart();
            }
        });
        const canvas = (ref) => h('canvas', {
            id: props.id,
            height: props.height,
            width: props.width,
            onClick: (e) => handleOnClick(e),
            role: 'img',
            ref: ref,
        }, {
            fallbackContent: () => slots.fallback && slots.fallback(),
        });
        return () => props.wrapper ? h('div', { class: 'chart-wrapper' }, canvas(canvasRef)) : canvas(canvasRef);
    },
});

const CChartProps = {
    customTooltips: {
        type: Boolean,
        default: true,
        required: false,
    },
    data: {
        type: [Object, Function],
        required: true,
    },
    height: {
        type: Number,
        default: 150,
        required: false,
    },
    id: {
        type: String,
        default: undefined,
        required: false,
    },
    options: {
        type: Object,
        default: undefined,
        required: false,
    },
    plugins: {
        type: Array,
        default: undefined,
        required: false,
    },
    redraw: Boolean,
    width: {
        type: Number,
        default: 300,
        required: false,
    },
    wrapper: {
        type: Boolean,
        default: true,
        required: false,
    },
};
const CChartBar = defineComponent({
    name: 'CChartBar',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'bar', ...props });
    },
});
const CChartBubble = defineComponent({
    name: 'CChartBubble',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'bubble', ...props });
    },
});
const CChartDoughnut = defineComponent({
    name: 'CChartDoughnut',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'doughnut', ...props });
    },
});
const CChartLine = defineComponent({
    name: 'CChartLine',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'line', ...props });
    },
});
const CChartPie = defineComponent({
    name: 'CChartPie',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'pie', ...props });
    },
});
const CChartPolarArea = defineComponent({
    name: 'CChartPolarArea',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'polarArea', ...props });
    },
});
const CChartRadar = defineComponent({
    name: 'CChartRadar',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'radar', ...props });
    },
});
const CChartScatter = defineComponent({
    name: 'CChartScatter',
    props: CChartProps,
    setup(props) {
        return () => h(CChart, { type: 'scatter', ...props });
    },
});
const CChartPlugin = {
    install: (app) => {
        app.component('CChart', CChart);
        app.component('CChartBar', CChartBar);
        app.component('CChartBubble', CChartBubble);
        app.component('CChartDoughnut', CChartDoughnut);
        app.component('CChartLine', CChartLine);
        app.component('CChartPie', CChartPie);
        app.component('CChartPolarArea', CChartPolarArea);
        app.component('CChartRadar', CChartRadar);
        app.component('CChartScatter', CChartScatter);
    },
};

export { CChart, CChartBar, CChartBubble, CChartDoughnut, CChartLine, CChartPie, CChartPolarArea, CChartRadar, CChartScatter, CChartPlugin as default };
//# sourceMappingURL=index.esm.js.map
